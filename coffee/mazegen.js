// Generated by CoffeeScript 1.10.0
(function() {
  var Cell, generateMaze, height, width;

  Cell = function() {
    this.init = false;
    return this.walls = 0x1111;
  };

  Cell.walls = {
    UP: 0x1000,
    DOWN: 0x0100,
    LEFT: 0x0010,
    RIGHT: 0x0001
  };

  Cell.dummy = new Cell();

  Cell.dummy.init = true;

  this.Map = function(width, height) {
    this.width = width;
    this.height = height;
    this.cells = [];
    this.entrance = {
      x: Math.floor(Math.random() * width),
      y: 0
    };
    this.exit = {
      x: Math.floor(Math.random() * width),
      y: this.height - 1
    };
    console.log('Entrance', this.entrance);
    console.log('Exit', this.exit);
    this.init();
    return this;
  };

  Map.prototype.init = function() {
    var i, k, ref, results, size;
    size = this.width * this.height;
    results = [];
    for (i = k = 0, ref = size; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
      results.push(this.cells.push(new Cell()));
    }
    return results;
  };

  Map.prototype.getCell = function(x, y) {
    var i;
    i = y * this.width + x;
    return this.cells[i];
  };

  Map.prototype.setWall = function(x, y, wall) {
    var i;
    i = y * this.width + x;
    return this.cells[i].walls = wall;
  };

  Map.prototype.clearWall = function(x, y, wall) {
    var i;
    i = y * this.width + x;
    return this.cells[i].walls ^= wall;
  };

  Map.prototype.getNeightbours = function(x, y) {
    return {
      up: y > 0 ? this.getCell(x, y - 1) : Cell.dummy,
      down: y < this.height - 1 ? this.getCell(x, y + 1) : Cell.dummy,
      left: x > 0 ? this.getCell(x - 1, y) : Cell.dummy,
      right: x < this.width - 1 ? this.getCell(x + 1, y) : Cell.dummy
    };
  };

  Map.prototype.generate = function() {
    var cell, check, keys, neighbours, next, rand, self, shuffle, stack, x, y;
    this.clearWall(this.entrance.x, this.entrance.y, Cell.walls.UP);
    this.clearWall(this.exit.x, this.exit.y, Cell.walls.DOWN);
    stack = [];
    self = this;
    keys = ['up', 'down', 'left', 'right'];
    shuffle = function(arr) {
      var i, j, k, ref, ref1;
      for (i = k = ref = arr.length - 1; ref <= 0 ? k <= 0 : k >= 0; i = ref <= 0 ? ++k : --k) {
        j = Math.floor(Math.random() * i);
        ref1 = [arr[j], arr[i]], arr[i] = ref1[0], arr[j] = ref1[1];
      }
      return arr;
    };
    x = 0;
    y = 0;
    while (true) {
      cell = self.getCell(x, y);
      if (cell.init) {
        stack.pop();
        next = stack.pop();
        self.getCell(next.x, next.y).init = false;
        if (stack.length > 0) {
          x = next.x;
          y = next.y;
          continue;
        }
        return true;
      }
      cell.init = true;
      stack.push({
        x: x,
        y: y
      });
      neighbours = self.getNeightbours(x, y);
      keys = shuffle(keys);
      check = 0;
      rand = 0;
      while (check++ < keys.length) {
        rand = keys[check - 1];
        switch (rand) {
          case 'up':
            if (!neighbours.up.init) {
              self.clearWall(x, y, Cell.walls.UP);
              self.clearWall(x, y - 1, Cell.walls.DOWN);
              y--;
              check = keys.length;
            }
            break;
          case 'down':
            if (!neighbours.down.init) {
              self.clearWall(x, y, Cell.walls.DOWN);
              self.clearWall(x, y + 1, Cell.walls.UP);
              y++;
              check = keys.length;
            }
            break;
          case 'left':
            if (!neighbours.left.init) {
              self.clearWall(x, y, Cell.walls.LEFT);
              self.clearWall(x - 1, y, Cell.walls.RIGHT);
              x--;
              check = keys.length;
            }
            break;
          case 'right':
            if (!neighbours.right.init) {
              self.clearWall(x, y, Cell.walls.RIGHT);
              self.clearWall(x + 1, y, Cell.walls.LEFT);
              x++;
              check = keys.length;
            }
        }
      }
    }
  };

  Map.prototype.toString = function() {
    var cell, cellCord, genToArr, generateGrid, getSteps, grid, gridCord, gridToString, height, i, k, len, ref, steps, toGridCord, width;
    width = this.width;
    height = this.height;
    steps = function*() {
      var i, k, l, ref, ref1, x, y;
      for (y = k = 0, ref = height; 0 <= ref ? k <= ref : k >= ref; y = 0 <= ref ? ++k : --k) {
        for (x = l = 0, ref1 = width; 0 <= ref1 ? l <= ref1 : l >= ref1; x = 0 <= ref1 ? ++l : --l) {
          i = y * width + x;
          (yield ({
            x: x,
            y: y,
            i: i
          }));
        }
      }
    };
    getSteps = function() {
      var i, k, l, p, ref, ref1, x, y;
      steps = [];
      for (y = k = 0, ref = height - 1; 0 <= ref ? k <= ref : k >= ref; y = 0 <= ref ? ++k : --k) {
        for (x = l = 0, ref1 = width - 1; 0 <= ref1 ? l <= ref1 : l >= ref1; x = 0 <= ref1 ? ++l : --l) {
          i = y * width + x;
          p = {
            x: x,
            y: y,
            i: i
          };
          steps.push(p);
        }
      }
      return steps;
    };
    genToArr = function(gen) {
      var arr, g, k, len;
      arr = [];
      for (k = 0, len = gen.length; k < len; k++) {
        g = gen[k];
        arr.push(g);
      }
      return arr;
    };
    this.mysteps = getSteps();
    toGridCord = function(p) {
      var i, x, y;
      x = 2 * p.x + 1;
      y = 2 * p.y + 1;
      i = y * (2 * width + 1) + x;
      return {
        x: x,
        y: y,
        i: i
      };
    };
    generateGrid = function() {
      var i, k, map, ref;
      map = [];
      for (i = k = 0, ref = (2 * width + 1) * (2 * height + 1) - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        map.push('*');
      }
      return map;
    };
    gridToString = function(grid) {
      var ch, i, k, len, txt;
      i = 0;
      txt = '';
      width = 2 * width + 1;
      for (k = 0, len = grid.length; k < len; k++) {
        ch = grid[k];
        txt += ch;
        if (!(++i % width)) {
          txt += '\n';
        }
      }
      return txt;
    };
    grid = generateGrid();
    ref = getSteps();
    for (k = 0, len = ref.length; k < len; k++) {
      cellCord = ref[k];
      gridCord = toGridCord(cellCord);
      cell = this.getCell(cellCord.x, cellCord.y);
      grid[gridCord.i] = ' ';
      if (!(cell.walls & Cell.walls.UP)) {
        i = (gridCord.y - 1) * (2 * width + 1) + gridCord.x;
        grid[i] = ' ';
      }
      if (!(cell.walls & Cell.walls.DOWN)) {
        i = (gridCord.y + 1) * (2 * width + 1) + gridCord.x;
        grid[i] = ' ';
      }
      if (!(cell.walls & Cell.walls.LEFT)) {
        i = gridCord.y * (2 * width + 1) + gridCord.x - 1;
        grid[i] = ' ';
      }
      if (!(cell.walls & Cell.walls.RIGHT)) {
        i = gridCord.y * (2 * width + 1) + gridCord.x + 1;
        grid[i] = ' ';
      }
    }
    this.txtMap = gridToString(grid);
    console.log('map');
    console.log(this.txtMap);
    return this.txtMap;
  };

  generateMaze = function(width, height) {
    var entranceStar, exitStar, map, txtMap;
    map = new Map(width, height);
    map.generate();
    txtMap = map.toString();
    console.log('Entrance', map.entrance);
    entranceStar = {
      x: 2 * map.entrance.x + 1,
      y: 0
    };
    exitStar = {
      x: 2 * map.exit.x + 1,
      y: 2 * map.exit.y + 2
    };
    console.log('Map entrance:', map.entrance);
    console.log('Grid entrance:', entranceStar);
    console.log('Map exit:', map.exit);
    console.log('Grid exit:', exitStar);
    return {
      start: entranceStar,
      end: exitStar,
      width: 2 * width + 2,
      height: 2 * height + 2,
      map: txtMap
    };
  };

  width = Math.floor(this.window.innerWidth / 2 / Constant.SQUARE) - 1;

  height = Math.floor(this.window.innerHeight / 2 / Constant.SQUARE) - 1;

  this.maze = generateMaze(width, height);

}).call(this);

//# sourceMappingURL=mazegen.js.map
